I"6H<ul>
  <li>JavaScript的执行机制 － eventloop</li>
  <li>作用域链与引用类型</li>
  <li>V8引擎内存问题</li>
</ul>

<h2 id="javascript的执行机制--eventloop">JavaScript的执行机制 － eventloop</h2>

<p>执行顺序：</p>

<p>开始执行  ＝&gt; 逐步执行代码  =&gt; 有代码异步操作 ＝&gt;  异步操作插入到异步队列 =&gt; 全部执行完毕 
=&gt; 询问是否有异步 =&gt; 异步队列 =&gt; 异步任务的回调回到主任务执行</p>

<p>异步队列里包含微任务和宏任务</p>
<ul>
  <li>宿主环境（常见的两种宿主环境有浏览器和node）提供的叫宏任务，由语言标准（比如ES6提供的promise）提供的叫微任务</li>
  <li>微任务：Promise, process.nextTick</li>
  <li>宏任务：整体代码script、setTimeout、setInterval</li>
  <li>async本身不是异步操作， await是等待，后面的代码都不执行，await从使用上来说，必须等待一个promise</li>
</ul>

<p>学习微宏任务，异步</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="c1">// 一、学习微宏任务，异步</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">set1</span><span class="dl">'</span><span class="p">);</span>
  <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">){</span>
    <span class="nx">resolve</span><span class="p">();</span>
  <span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">then3</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>微任务会先于宏任务； 微任务队列空了，才会执行下一个宏任务，异步队列执行的时候，只要有微任务，都优先执行微任务</p>

<h2 id="传统异步解决方案">传统异步解决方案</h2>

<h4 id="一callback回调">一、callback回调</h4>

<p>通过参数闯入回调，未来调用回调时让函数的调用者判断发生了什么？回调函数被认为是一种高级函数，一种被作为参数传递给另一个函数(在这称作”otherFunction”)的高级函数</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="o">&lt;</span><span class="nx">img</span> <span class="nx">src</span><span class="o">=</span><span class="dl">'</span><span class="s1">../a.jpg</span><span class="dl">'</span><span class="o">&gt;&lt;</span><span class="sr">/img</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="nx">img</span> <span class="nx">src</span><span class="o">=</span><span class="dl">'</span><span class="s1">../b.jpg</span><span class="dl">'</span><span class="o">&gt;&lt;</span><span class="sr">/img</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="nx">img</span> <span class="nx">src</span><span class="o">=</span><span class="dl">'</span><span class="s1">../c.jpg</span><span class="dl">'</span><span class="o">&gt;&lt;</span><span class="sr">/img</span><span class="err">&gt;
</span>
<span class="nx">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">img</span><span class="dl">"</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="dl">"</span><span class="s2">title</span><span class="dl">"</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span><span class="nx">attr</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="c1">// 依次返回0 1 2</span>
<span class="p">});</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<ul>
  <li>优点：简单、容易理解和部署</li>
  <li>缺点：不利于代码的阅读和维护，程序流程混乱，每个任务只能指定一个回调函数</li>
</ul>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="err">目录结构：</span><span class="w">
</span><span class="o">-</span><span class="w"> </span><span class="no">iamswr</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="nn">A</span><span class="p">.</span><span class="no">txt</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="nn">B</span><span class="p">.</span><span class="no">txt</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="nn">C</span><span class="p">.</span><span class="no">txt</span><span class="w">
  
  </span><span class="err">其中</span><span class="w">
  </span><span class="nn">A</span><span class="p">.</span><span class="no">txt</span><span class="err">文件里的内容为字符串</span><span class="nn">B</span><span class="p">.</span><span class="no">txt</span><span class="w">
  </span><span class="nn">B</span><span class="p">.</span><span class="no">txt</span><span class="err">文件里的内容为字符串</span><span class="nn">C</span><span class="p">.</span><span class="no">txt</span><span class="w">
  </span><span class="nn">C</span><span class="p">.</span><span class="no">txt</span><span class="err">文件里的内容为字符串</span><span class="k">'</span><span class="no">hello</span><span class="w"> </span><span class="no">swr'</span><span class="w">
  
  </span><span class="err">那么当我们想获取到</span><span class="k">'</span><span class="no">hello</span><span class="w"> </span><span class="no">swr'</span><span class="err">，会遇到什么问题呢？请看下面的代码</span><span class="w">
  </span><span class="kr">let</span><span class="w"> </span><span class="no">fs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">require</span><span class="o">(</span><span class="k">'</span><span class="no">fs'</span><span class="o">)</span><span class="w">
  </span><span class="nn">fs</span><span class="p">.</span><span class="no">readFile</span><span class="o">(</span><span class="k">'</span><span class="nn">A</span><span class="p">.</span><span class="no">txt'</span><span class="o">,</span><span class="k">'</span><span class="no">utf8'</span><span class="o">,</span><span class="no">function</span><span class="o">(</span><span class="no">err</span><span class="o">,</span><span class="no">data</span><span class="o">){</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="err">此时回调函数</span><span class="no">data</span><span class="err">值为</span><span class="k">'</span><span class="nn">B</span><span class="p">.</span><span class="no">txt'</span><span class="w">
      </span><span class="nn">fs</span><span class="p">.</span><span class="no">readFile</span><span class="o">(</span><span class="no">data</span><span class="o">,</span><span class="k">'</span><span class="no">utf8'</span><span class="o">,</span><span class="no">function</span><span class="o">(</span><span class="no">err</span><span class="o">,</span><span class="no">data</span><span class="o">){</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="err">此时回调函数</span><span class="no">data</span><span class="err">值为</span><span class="k">'</span><span class="nn">C</span><span class="p">.</span><span class="no">txt'</span><span class="w">
          </span><span class="nn">fs</span><span class="p">.</span><span class="no">readFile</span><span class="o">(</span><span class="no">data</span><span class="o">,</span><span class="k">'</span><span class="no">utf8'</span><span class="o">,</span><span class="no">function</span><span class="o">(</span><span class="no">err</span><span class="o">,</span><span class="no">data</span><span class="o">){</span><span class="w">
            </span><span class="nn">console</span><span class="p">.</span><span class="no">log</span><span class="o">(</span><span class="no">data</span><span class="o">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="k">'</span><span class="no">hello</span><span class="w"> </span><span class="no">swr'</span><span class="w">
          </span><span class="o">})</span><span class="w">
      </span><span class="o">})</span><span class="w">
  </span><span class="o">})</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="二事件发布订阅模式">二、事件发布／订阅模式</h4>

<p>回调函数的事件化，任务的执行不取决于代码的顺序，而取决于某个事件是否发生</p>

<ul>
  <li>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li>
  <li>缺点：整个程序变成了事件驱动型，运行流程会变得很不清晰</li>
</ul>

<h4 id="三deferred延迟函数">三、Deferred延迟函数</h4>

<p>通过deferred对象给异步操作进行状态绑定，deferred对象提供统一的api, 对各种异步操作状态进行操作（成功、失败、进行中）</p>

<ul>
  <li>优点：避免了层层嵌套的回调函数deferred对象提供统一的接口，控制异步操作更容易；</li>
  <li>缺点：状态不可逆，从待定状态切换到任何一个确定状态后，再次调用resole和reject对愿状态将不起任何作用；</li>
</ul>

<h2 id="认识promise">认识Promise</h2>

<blockquote>
  <p>思考： 用同步化的方法来书写异步代码</p>
</blockquote>

<p>异步操作的状态管理：成功\失败\进行中，每一个状态管理一个容器（3个），即成功之后的事情（找到对应的callback）、失败之后的事情（找到对应的callback）、进行中之后的事情（找到对应的callback）</p>

<ul>
  <li><code class="highlighter-rouge">成功</code> resolve()</li>
  <li><code class="highlighter-rouge">失败</code> reject()</li>
  <li><code class="highlighter-rouge">进行中</code></li>
</ul>

<p>知识普及：</p>
<blockquote>
  <p>闭包最大用处： 一个可以读取函数内部的变量，另一个就是让这些变量值保持在内存中；
思考：封闭作用域，保存作用域，作用域链条, 不污染全局变量、块级作用域</p>
</blockquote>

<p>Promise的一些特性</p>
<ul>
  <li>promise是有兼容性问题的，node环境下默认支持，还可以下载相应插件来解决兼容性问题</li>
  <li>promise是有三种状态的，等待态pending / 成功态resolved / 失败态rejected</li>
  <li>promise的状态是可以转换的，可以从pending -&gt; resolved 或 pending -&gt; rejected，但是resolved不能转换为rejected/pending，rejected不能转换为resolved/pending，简而言之即状态只会更改一次</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="c1">// Promise构造函数的第一个参数为executor</span>
<span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">我是会被立即执行的哟</span><span class="dl">'</span><span class="p">)</span>
<span class="p">})</span>

<span class="c1">// promise的实例都有then方法</span>
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span> <span class="c1">// 成功的回调</span>
    
<span class="p">},()</span><span class="o">=&gt;</span><span class="p">{</span> <span class="c1">// 失败的回调</span>
    
<span class="p">})</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>executor默认在new的时候会自动执行</li>
  <li>每个promise的实例都有then方法</li>
  <li>then方法中，有两个参数，分别是成功的回调函数和失败的回调函数</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="c1">// 默认时为pending态，既不会走成功的回调也不会走失败的回调</span>
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">success1</span><span class="dl">'</span><span class="p">)</span>
<span class="p">},()</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">error1</span><span class="dl">'</span><span class="p">)</span>
<span class="p">})</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">)</span>

<span class="c1">// 在这段代码中，只会打印出'2'，因为promise一直处于pending态，不会走then后的回调函数</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">)</span>
    <span class="nx">resolve</span><span class="p">()</span> <span class="c1">// 更改pending状态为resolved</span>
<span class="p">})</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">success1</span><span class="dl">'</span><span class="p">)</span>
<span class="p">},()</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">error1</span><span class="dl">'</span><span class="p">)</span>
<span class="p">})</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">)</span>

<span class="c1">// 此时输出顺序为'1' -&gt; '2' -&gt; 'success1'</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>then方法是异步的，属于微任务，从上面的例子可以看出，先执行完同步代码，再执行异步代码</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">)</span>
    <span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span> <span class="c1">// 异步行为</span>
        <span class="nx">resolve</span><span class="p">()</span> <span class="c1">// 更改状态为成功</span>
    <span class="p">},</span><span class="mi">1000</span><span class="p">)</span>
<span class="p">})</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">success1</span><span class="dl">"</span><span class="p">)</span>
<span class="p">})</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">success2</span><span class="dl">'</span><span class="p">)</span>
<span class="p">})</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">)</span>

<span class="c1">// 此时输出顺序为'1' -&gt; '2' -&gt; 'success1' -&gt; 'success2'</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>同一个promise的实例可以then多次,成功时会调用所有的成功方法，失败时会调用所有的失败方法</li>
  <li>new Promise中可以支持异步行为</li>
  <li>如果发现错误，就会进入失败态</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">出错了</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 抛出错误</span>
<span class="p">})</span>

<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">success1</span><span class="dl">'</span><span class="p">)</span>
<span class="p">},()</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">error1</span><span class="dl">'</span><span class="p">)</span>
<span class="p">})</span>

<span class="c1">// 此时输出为 'error1'</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="实现一个promise">实现一个Promise</h2>
<h6 id="基础结构">基础结构</h6>

<p>下面代码部分和源码实现部分要结合来看</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="c1">// ----- 代码部分</span>
<span class="c1">// 1.executor默认在new的时候会自动执行</span>
<span class="c1">// 成功和失败的视乎可以传递参数</span>
<span class="kd">let</span> <span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span> <span class="c1">// 6.resolve、reject函数对应源码实现部分的resolve、reject函数</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello swr</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 11.执行resolve</span>
<span class="p">})</span>

<span class="c1">// 7.Promise的实例都有then方法</span>
<span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span> <span class="c1">// 8.成功的回调函数</span>
    
<span class="p">},(</span><span class="nx">err</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span> <span class="c1">// 9.失败的回调函数</span>
    
<span class="p">})</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre><span class="c1">// ----- 源码实现部分</span>
<span class="c1">// 2.声明一个Promise构造函数</span>
<span class="kd">function</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">executor</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span>
    <span class="nb">self</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="kc">undefined</span>
    <span class="nb">self</span><span class="p">.</span><span class="nx">reason</span> <span class="o">=</span> <span class="kc">undefined</span> <span class="c1">// 12.因为value和reason值需要在Promise实例方法then中使用，所以把这两个值，赋给new出来的实例</span>
    <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span> <span class="c1">// 3.声明一个resolve函数</span>
      <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">pending</span><span class="dl">'</span><span class="p">){</span> <span class="c1">// 2.此时新增一个状态判断，当状态为pending的时候才能执行</span>
        <span class="nb">self</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span> <span class="c1">// 13.当调用了resolve并且传参数时，则把这value值赋予self.value</span>
        <span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">resolved</span><span class="dl">'</span> <span class="c1">// 2.当调用了resolve时，更改状态为resolved</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">){</span> <span class="c1">// 4.声明一个reject函数</span>
     <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">pending</span><span class="dl">'</span><span class="p">){</span> <span class="c1">// 2.此时新增一个状态判断，当状态为pending的时候才能执行</span>
        <span class="nb">self</span><span class="p">.</span><span class="nx">reason</span> <span class="o">=</span> <span class="nx">reason</span> <span class="c1">// 13.当调用了reject并且传参数时，则把这reason值赋予self.reason</span>
        <span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">rejected</span><span class="dl">'</span> <span class="c1">// 2.当调用了reject时，更改状态为rejected</span>
     <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 5.当我们在执行executor时，内部抛出错误的时候，可以利用try catch来处理这个问题</span>
    <span class="k">try</span><span class="p">{</span>
        <span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span>
    <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span><span class="p">){</span>
        <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 因为Promise的实例都有then方法，那么意味着then方法是在Promise的原型对象中的方法</span>
<span class="c1">// 10.对应上面成功的回调函数onFulfilled以及失败的回调函数onRejected</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onFulfilled</span><span class="p">,</span><span class="nx">onRejected</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span>
    <span class="c1">// 3.当我们在then中，执行了成功或者失败的回调函数时，首先要判断目前处于什么状态</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">resolved</span><span class="dl">'</span><span class="p">){</span>
        <span class="nx">onFulfilled</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="c1">// 4.当调用了resolve函数后，会执行成功的回调函数，并且把resolve中传递的值，传递给成功的回调函数</span>
    <span class="p">}</span>
    
    <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">rejected</span><span class="dl">'</span><span class="p">){</span>
        <span class="nx">onRejected</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">reason</span><span class="p">)</span> <span class="c1">// 4.当调用了reject函数后，会执行成功的回调函数，并且把reject中传递的值，传递给失败的回调函数</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nb">Promise</span> <span class="c1">// 把Promise暴露出去</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>思考：如果此时resolve或者reject是处于setTimeout(()=&gt;{resolve()},3000)中，即处于异步中，当我们new一个Promise时，不会马上执行异步代码，而是直接执行了promise.then这个函数，而此时因为self.status的状态依然是处于pending，所以不会执行resolve或者reject，当同步代码执行完毕后，执行异步代码时，更改了状态为resolved或者rejected时，此时then方法已经执行完毕了，不会再次执行then的方法，那么此时我们该如何处理？</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre></td><td class="rouge-code"><pre>
<span class="c1">// ----- 源码实现部分</span>
<span class="kd">function</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">executor</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span>
    <span class="nb">self</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="kc">undefined</span>
    <span class="nb">self</span><span class="p">.</span><span class="nx">reason</span> <span class="o">=</span> <span class="kc">undefined</span> 
    <span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">pending</span><span class="dl">'</span>
    <span class="nb">self</span><span class="p">.</span><span class="nx">onResolvedCallbacks</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">// 2.可能new Promise中会有异步的操作，此时我们把异步操作时，执行的then函数的成功回调，统一保存在该数组中</span>
    <span class="nb">self</span><span class="p">.</span><span class="nx">onRejectedCallbacks</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">// 2.可能new Promise中会有异步的操作，此时我们把异步操作时，执行的then函数的失败回调，统一保存在该数组中</span>
    <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">pending</span><span class="dl">'</span><span class="p">){</span> 
            <span class="nb">self</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span> 
            <span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">resolved</span><span class="dl">'</span>
            <span class="c1">// 4.当调用resolve时，把该数组中存放的成功回调都执行一遍，如果是异步，则会把成功的回调都存到该数组里了，如果是异步，则没存到。</span>
            <span class="nb">self</span><span class="p">.</span><span class="nx">onResolvedCallbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">fn</span><span class="o">=&gt;</span><span class="nx">fn</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">pending</span><span class="dl">'</span><span class="p">){</span> 
            <span class="nb">self</span><span class="p">.</span><span class="nx">reason</span> <span class="o">=</span> <span class="nx">reason</span> 
            <span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">rejected</span><span class="dl">'</span>
            <span class="c1">// 4.当调用reject时，把该数组中存放的失败回调都执行一遍，如果是异步，则会把成功的回调都存到该数组里了，如果是异步，则没存到。</span>
            <span class="nb">self</span><span class="p">.</span><span class="nx">onRejectedCallbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">fn</span><span class="o">=&gt;</span><span class="nx">fn</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">try</span><span class="p">{</span>
        <span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span>
    <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span><span class="p">){</span>
        <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onFulfilled</span><span class="p">,</span><span class="nx">onRejected</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">resolved</span><span class="dl">'</span><span class="p">){</span>
        <span class="nx">onFulfilled</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> 
    <span class="p">}</span>
    
    <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">rejected</span><span class="dl">'</span><span class="p">){</span>
        <span class="nx">onRejected</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">reason</span><span class="p">)</span> 
    <span class="p">}</span>
    
    <span class="c1">// 3.当new Promise中有resolve、reject处于异步中，执行then的时候，状态为pending，</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">pending</span><span class="dl">'</span><span class="p">){</span>
        <span class="nb">self</span><span class="p">.</span><span class="nx">onResolvedCallbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
            <span class="nx">onFulfilled</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
        <span class="p">})</span> <span class="c1">// 3. 把成功的回调函数，存到该数组中，这样写的好处，就是把参数传进去，不需要将来遍历onResolvedCallbacks时，再传参</span>
        <span class="nb">self</span><span class="p">.</span><span class="nx">onRejectedCallbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
            <span class="nx">onRejected</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">reason</span><span class="p">)</span>
        <span class="p">})</span> <span class="c1">// 3. 把失败的回调函数，存到该数组中，这样写的好处，就是把参数传进去，不需要将来遍历onRejectedCallbacks时，再传参</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nb">Promise</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>思考：同一个promise的实例可以then多次,成功时会调用所有的成功方法，失败时会调用所有的失败方法，那这个又该如何处理呢？</p>
</blockquote>

<h6 id="promise的链式调用">Promise的链式调用</h6>

<p>其实Promise的核心在于链式调用，Promise主要是解决2个问题：</p>
<ul>
  <li>回调地狱</li>
  <li>并发异步io操作，同一时间内把这个结果拿到，即比如有两个异步io操作，当这2个获取完毕后，才执行相应的代码，比如前面所说的after函数，发布订阅、Promise.all等。</li>
</ul>

<p>用Promise方式可以得出结论:</p>

<ul>
  <li>1.如果一个promise执行完后，返回的还是一个promise，会把这个promise的执行结果会传递给下一次then中</li>
  <li>2.如果在then中返回的不是一个promise，而是一个普通值，会将这个普通值作为下次then的成功的结果</li>
  <li>3.如果当前then中失败了，会走下一个then的失败回调</li>
  <li>4.如果在then中不返回值，虽然没有显式返回，但是默认是返回undefined，是属于普通值，依然会把这个普通值传到下一个then的成功回调中</li>
  <li>5.catch是错误没有处理的情况下才会执行</li>
  <li>6.then中可以不写东西</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="rouge-code"><pre><span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onFulfilled</span><span class="p">,</span><span class="nx">onRejected</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span>
    <span class="kd">let</span> <span class="nx">promise2</span> <span class="c1">// 3.上面讲promise链式调用时，已经说了返回的是一个新的promise对象，那么我们声明一个新的promise</span>
    
    <span class="c1">// 4.那么我们new一个新的promise，并且把以下代码放到promise中</span>
    <span class="kd">let</span> <span class="nx">promise2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">resolved</span><span class="dl">'</span><span class="p">){</span>
            <span class="c1">// 7.当执行成功回调的时候，可能会出现异常，那么就把这个异常作为promise2的错误的结果</span>
            <span class="k">try</span><span class="p">{</span>
                <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">onFulfilled</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="c1">// 6.这里的x，就是上面then中执行完返回的结果，我们在这里声明一个x用来接收</span>
                <span class="c1">// 8.根据promiseA+规范，我们应该提供一个函数来处理promise2</span>
                <span class="c1">//   我个人的理解是，then中不管是成功回调还是失败回调，其返回</span>
                <span class="c1">//   值，有可能是promise，也有可能是普通值，也有可能是抛出错误</span>
                <span class="c1">//   那么我们就需要一个函数来处理这几种不同的情况</span>
                <span class="c1">//   这个函数我们声明为resolvePromise吧</span>
                <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span>
                <span class="c1">// 9. 这里的promise2就是当前的promise2，x则是执行then中成功回调后返回的结果，如果是成功则调promise2的resolve，失败则调reject</span>
            <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
                <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="c1">// 注意：这里的reject是这个promise2的reject</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">rejected</span><span class="dl">'</span><span class="p">){</span>
            <span class="c1">// 同6-7步</span>
            <span class="k">try</span><span class="p">{</span>
                <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">onRejected</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">reason</span><span class="p">)</span> 
                <span class="c1">// 同8-9</span>
                <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span>
            <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
                <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    
        <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">pending</span><span class="dl">'</span><span class="p">){</span>
            <span class="nb">self</span><span class="p">.</span><span class="nx">onResolvedCallbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
                <span class="c1">// 同6-7步</span>
                <span class="k">try</span><span class="p">{</span>
                    <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span>  <span class="nx">onFulfilled</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
                    <span class="c1">// 同8-9</span>
                    <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span>
                <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
                    <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">})</span> 
            <span class="nb">self</span><span class="p">.</span><span class="nx">onRejectedCallbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
                <span class="c1">// 同6-7步</span>
                <span class="k">try</span><span class="p">{</span>
                    <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">onRejected</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">reason</span><span class="p">)</span>
                    <span class="c1">// 同8-9</span>
                    <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span>
                <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
                    <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">})</span>
    <span class="k">return</span> <span class="nx">promise2</span> <span class="c1">// 5.在jquery中是return this，但是在promise中，则是返回一个新的promise对象</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h6 id="写一个resolvepromise函数">写一个resolvePromise函数</h6>

<p>接下来我们写一下resolvePromise这个函数，整个Promise最核心的部分就是在这里</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre></td><td class="rouge-code"><pre><span class="c1">// 1.声明一个resolvePromise函数</span>
<span class="c1">// 这个函数非常核心，所有的promise都遵循这个规范，所有的promise可以通用，</span>
<span class="cm">/**
 * 
 * @param {*} promise2 then的返回值，返回新的promise
 * @param {*} x then中成功函数或者失败函数的返回值
 * @param {*} resolve promise2的resolve
 * @param {*} reject promise2的reject
 */</span>
<span class="kd">function</span> <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span><span class="nx">x</span><span class="p">,</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">){</span>
    <span class="c1">// 3.从2中我们可以得出，自己不能等于自己</span>
    <span class="c1">// 当promise2和x是同一个对象的时候，则走reject</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">promise2</span> <span class="o">===</span> <span class="nx">x</span><span class="p">){</span>
        <span class="k">return</span> <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="dl">'</span><span class="s1">Chaining cycle detected for promise</span><span class="dl">'</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="c1">// 4.因为then中的返回值可以为promise，当x为对象或者函数，才有可能返回的是promise</span>
    <span class="kd">let</span> <span class="nx">called</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">x</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">object</span><span class="dl">'</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)){</span>
        <span class="c1">// 8.从第7步，可以看出为什么会存在抛出异常的可能，所以使用try catch处理</span>
        <span class="k">try</span><span class="p">{</span>
            <span class="c1">// 6.因为当x为promise的话，是存在then方法的</span>
            <span class="c1">// 但是我们取一个对象上的属性，也有可能出现异常，我们可以看一下第7步</span>
            <span class="kd">let</span> <span class="nx">then</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">then</span> 
            
            <span class="c1">// 9.我们为什么在这里用call呢？解决了什么问题呢？可以看上面的第10步</span>
            <span class="c1">// x可能还是个promise，那么就让这个promise执行</span>
            <span class="c1">// 但是还是存在一个恶作剧的情况，就是{then:{}}</span>
            <span class="c1">// 此时需要新增一个判断then是否函数</span>
            <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">){</span>
                <span class="nx">then</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">x</span><span class="p">,(</span><span class="nx">y</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span> <span class="c1">// y是返回promise后的成功结果</span>
                    <span class="c1">// 一开始我们在这里写的是resolve(y)，但是考虑到一点</span>
                    <span class="c1">// 这个y，有可能还是一个promise，</span>
                    <span class="c1">// 也就是说resolve(new Promise(...))</span>
                    <span class="c1">// 所以涉及到递归，我们把resolve(y)改成以下</span>
                    
                    <span class="c1">// 12.限制既调resolve，也调reject</span>
                    <span class="k">if</span><span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span>
                    <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span>
                    
                    <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span>
                    <span class="c1">// 这样的话，代码会一直递归，取到最后一层promise</span>
                    
                    <span class="c1">// 11.这里有一种情况，就是不能既调成功也调失败，只能挑一次，</span>
                    <span class="c1">// 但是我们前面不是处理过这个情况了吗？</span>
                    <span class="c1">// 理论上是这样的，但是我们前面也说了，resolvePromise这个函数</span>
                    <span class="c1">// 是所有promise通用的，也可以是别人写的promise，如果别人</span>
                    <span class="c1">// 的promise可能既会调resolve也会调reject，那么就会出问题了，所以我们接下来要</span>
                    <span class="c1">// 做一下限制，这个我们写在第12步</span>
                    
                <span class="p">},(</span><span class="nx">err</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span> <span class="c1">// err是返回promise后的失败结果</span>
                    <span class="k">if</span><span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span>
                    <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span>
                    <span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
                <span class="p">})</span>
            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// 如果then不是函数的话，那么则是普通对象，直接走resolve成功</span>
            <span class="p">}</span>
        <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span> <span class="c1">// 当出现异常则直接走reject失败</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span>
            <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span>
            <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span> <span class="c1">// 5.x为一个常量，则是走resolve成功</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h6 id="完整代码-也顺便带大家理顺一下">完整代码 也顺便带大家理顺一下</h6>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
</pre></td><td class="rouge-code"><pre><span class="kd">function</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">executor</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="nb">self</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// 成功的值</span>
  <span class="nb">self</span><span class="p">.</span><span class="nx">reason</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// 失败的值</span>
  <span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">pending</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// 目前promise的状态为pending，还有resolved、rejected</span>
  <span class="nb">self</span><span class="p">.</span><span class="nx">onResolvedCallbacks</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 可能new promise的时候存在异步操作，把成功和失败回调保存起来</span>
  <span class="nb">self</span><span class="p">.</span><span class="nx">onRejectedCallbacks</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="c1">// 把状态更改为成功</span>
  <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span> 
    <span class="c1">// 只有pending状态才能转为成功状态</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">pending</span><span class="dl">'</span><span class="p">){</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">resolved</span><span class="dl">"</span><span class="p">;</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">onResolvedCallbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">fn</span> <span class="o">=&gt;</span> <span class="nx">fn</span><span class="p">());</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">pending</span><span class="dl">'</span><span class="p">){</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">rejected</span><span class="dl">"</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">reason</span> <span class="o">=</span> <span class="nx">reason</span><span class="p">;</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">onRejectedCallbacks</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">fn</span> <span class="o">=&gt;</span> <span class="nx">fn</span><span class="p">());</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**
 * 所有的promise都遵循这个规范，所有的promise可以通用
 * @param {*} promise2  then的返回值，返回新的promise
 * @param {*} x then中成功函数或失败函数的返回值
 * @param {*} resolve  promise2的resolve
 * @param {*} reject promise2的reject
 */</span>
<span class="kd">function</span> <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">){</span>
  <span class="c1">// promise2和x是同一个对象，reject</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">promise2</span> <span class="o">===</span> <span class="nx">x</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="dl">'</span><span class="s1">Chaining cycle detected for promise</span><span class="dl">'</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">called</span><span class="p">;</span>
  <span class="c1">// then的返回值是promise，当x为对象或者函数，才可能是promise</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="o">!==</span><span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">object</span><span class="dl">'</span> <span class="o">||</span> <span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">)){</span>

    <span class="k">try</span><span class="p">{</span>
      <span class="kd">let</span> <span class="nx">then</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">then</span><span class="p">;</span>
      <span class="c1">// x可以还是个promise，排除{then:{}}</span>
      <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">then</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="p">){</span>
        <span class="nx">then</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="p">(</span><span class="nx">y</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
          <span class="c1">// y是返回promise后成功结果</span>
          <span class="c1">// 如果别人的promise可能既会调resolve也会调reject，那么就会出问题了，所以我们接下来要限制</span>
          <span class="k">if</span><span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
          <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="c1">// 代码会一直递归，取到最后一层promis</span>
          <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
       
        <span class="p">},(</span><span class="nx">err</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
          <span class="c1">// 返回promise失败结果</span>
          <span class="k">if</span><span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
          <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
          <span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
        <span class="p">});</span>
      <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// 如果then不是函数的话，那么则是普通对象，直接走resolve成功</span>
      <span class="p">}</span>
    <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">called</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
      <span class="nx">called</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="c1">// x为一个常量，则是走resolve成功</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">then</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onFullfilled</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="c1">// 那么我们new一个新的promise，并且把以下代码放到promise中</span>
  <span class="kd">let</span> <span class="nx">promise2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">resolved</span><span class="dl">'</span><span class="p">){</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="c1">// 这里的x， 上一层then执行返回的结果</span>
        <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">onFullfilled</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
        <span class="c1">// 提供一个resolvePromise函数处理promise2， then不管是成功回调、失败回调，返回值可能为promise／普通值／抛出错误值</span>
        <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
        <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">rejected</span><span class="dl">'</span><span class="p">){</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span>  <span class="nx">onRejected</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">reason</span><span class="p">);</span>
        <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
        <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">pending</span><span class="dl">'</span><span class="p">){</span>
      <span class="c1">// 把成功回调函数，存到改数组中，把参数传进去，不需要将来遍历onResolvedCallbacks时，再传参</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">onResolvedCallbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(()</span><span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">onFullfilled</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
            <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
          <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">});</span>
      <span class="nb">self</span><span class="p">.</span><span class="nx">onRejectedCallbacks</span><span class="p">.</span><span class="nx">push</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
          <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span>  <span class="nx">onRejected</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">reason</span><span class="p">);</span>
          <span class="nx">resolvePromise</span><span class="p">(</span><span class="nx">promise2</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
          <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">promise2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 是否为模块引入，健壮性判断</span>
<span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">module</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">undefined</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">undefined</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">define</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="nx">define</span><span class="p">.</span><span class="nx">amd</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">define</span><span class="p">([],</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">Promise</span><span class="p">;</span>
    <span class="p">});</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nb">window</span><span class="p">.</span><span class="nb">Promise</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h6 id="常用的promise方法">常用的promise方法</h6>

<p>接下来，我们完善一下这个promise，写一下常用的promise方法</p>

<ul>
  <li>Promise.reject</li>
  <li>Promise.resolve</li>
  <li>catch</li>
  <li>Promise.all</li>
  <li>Promise.race</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="rouge-code"><pre><span class="c1">// 简化的promise, 语法糖可以简化一些操作</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">defer</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">deferred</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="kd">let</span> <span class="nx">dfd</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="nx">dfd</span><span class="p">.</span><span class="nx">promise</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">dfd</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">=</span><span class="nx">resolve</span><span class="p">;</span>
    <span class="nx">dfd</span><span class="p">.</span><span class="nx">reject</span> <span class="o">=</span><span class="nx">reject</span><span class="p">;</span>
  <span class="p">});</span>
  <span class="k">return</span> <span class="nx">dfd</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 原生的Promise.resolve使用</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">reason</span><span class="p">){</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="k">catch</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">onRejected</span><span class="p">){</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">onRejected</span><span class="p">);</span>
<span class="p">}</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">promises</span><span class="p">){</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">processData</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">data</span><span class="p">){</span>
      <span class="nx">arr</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
       <span class="c1">// 所有结束时候</span>
      <span class="k">if</span><span class="p">(</span><span class="o">++</span><span class="nx">i</span> <span class="o">===</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">){</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="nx">promises</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span><span class="o">=&gt;</span> <span class="nx">processData</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">data</span><span class="p">),</span> <span class="nx">reject</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">promises</span><span class="p">){</span>
  <span class="k">return</span>  <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">promises</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
      <span class="nx">promises</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">then</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<p>结尾：希望对大家有所帮助，promise的源码实现，我最大的收获并不是怎么实现promise，而是编程思维，大家可以多多往深里想一想，也希望大家可以和我进行交流，共同进步</p>
:ET